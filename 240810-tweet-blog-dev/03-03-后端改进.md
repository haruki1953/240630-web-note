### 解决帖子图片顺序无法控制的问题
在Post表添加 imagesOrder 字段，保存图片id数组json字符串
```
imagesOrder  String?
```

运行迁移命令以生成和应用迁移：
```
pnpm prisma migrate dev --name add-imagesOrder
`imagesOrder` 是一个可选字段（通过 `?` 标记），所以它不会对现有的数据造成影响，也不需要为现有的记录提供默认值。
为了使其之前数据库中的数据不受影响，前端判断得到的imagesOrder为null时，则以images本身为准
```

修改后端
```
在发送帖子、修改帖子时，保存图片id数组
```


### 状态管理改进
封装defineStoreSystem，更改save方法

### 优化项目结构
将项目业务相关的零散方法放在 `src/utils`，而将为了方便开发的封装放在 `src/helpers`

### 个人信息功能
- 头像
- 名称
- 简介
- 社交媒体
- 关于（markdown）
- 外链（友情链接/联系方式）

都保存存在json里
```
实现头像与其记录，需要当前头像标记，还需要一个数组
avatar avatarArray
avatar为uuid，前端据此在avatarArray中查找。找不到或avatar为null时，显示默认logo

名称，

要实现外链，需要有两个数组：
外链信息 externalLinks ，外链图标 externalIcons
```

后端新增profileSystem
```
类型，校验模型
默认值
```

图片处理
```
确认存储位置，在system/file中添加avatar与iconSystem，实现存储与删除，之后会由profileSystem调用
关于头像与外链图标，完全由前端进行压缩处理，后端不做处理
```

路由、接口新增
- 编写接口文档
- 编写表单校验schema
- 编写路由
- 编写服务函数
- 测试，完善接口文档
```
新增profile路由

profileGetAll 获取全部信息，包括profileStore信息，帖子、图片统计
profileGetData 帖子、图片统计
profileGetStore 获取profileStore信息

profileUpdateNameBio
profileUpdateAboutMd
profileUpdateSocialMedias

profileAddAvatar
profileDeleteAvatarByUuid
profileDeleteAvatarNotUsed
profileUpdateAvatar

profileAddExternalIcon
profileDeleteExternalIconByUuid
profileDeleteExternalIconNotUsed
profileUpdateExternalLinks

```



### hono托管静态文件 
https://stackoverflow.com/questions/77838482/how-to-serve-static-files-in-node-js-using-hono-js

https://hono.dev/docs/getting-started/nodejs#serve-static-files

https://www.npmjs.com/package/@hono/node-server

```
将后端路由路由都加上 /api
后端新建 /static 目录，存放前端
图片等还是存在 /data/public

将静态托管内容写在 src\routers\static.ts
```

配置托管与缓存，hono文档里不是到为什么没有getContent，但是是必要的
```ts
import { serveStatic } from 'hono/serve-static'
import fsp from 'fs/promises'

router.use('*', serveStatic({
  root: './static',
  getContent: async (path, c) => {
    try {
      const content = await fsp.readFile(path)
      return content
    } catch (error) {
      // console.error('Error reading file:', error)
      return null
    }
  },
  onFound: (_path, c) => {
    c.header('Cache-Control', 'public, immutable, max-age=31536000')
  }
}))

// src\index.ts
app.route('/', staticRouter)
```

改进
```ts
router.use('*', serveStatic({
  root: staticConfig.root,
  getContent: async (path, c) => {
    try {
      const content = await fsp.readFile(path)
      return content
    } catch (error) {
      return null
    }
  },
  onFound: (_path, c) => {
    staticConfig.settings.forEach(setting => {
      if (setting.pathReg.test(_path)) {
        setting.headers.forEach(header => {
          c.header(header.name, header.value)
        })
      }
    })
  }
}))
```


### id从数字改为uuid
检查错误
```
配置 package.json
  "scripts": {
    "dev": "tsx watch src/index.ts",
    "lint": "eslint --ext .ts src"
  },
pnpm lint
（pnpm eslint --ext .ts src）

更全面的类型检查应该使用 TypeScript 编译器 `tsc`
tsc --noEmit

在 Vue 项目中，scripts中有"type-check"
pnpm type-check



```

prisma更改
```
id String @id @default(uuid())
注意，相关的关系字段也要修改

数据库名改为
datasource db {
  provider = "sqlite"
  url      = "file:../data/sqlite.db"
}

运行迁移
pnpm prisma migrate dev --name id-change-int-to-string-uuid
打开Prisma Studio内置GUI
pnpm prisma studio
```


后端更改
- type
- schema
- service
- 游标查询，空字符起始（之前是数字0）

前端更改
- type
- api
- store
- service
- data-handle
- 注意有用id当路由的页面

接口文档

### 使json数据版本兼容
当版本更新后，或许会增加数据，此时加载数据就会失败
```ts
  // load data from file
  const load = () => {
    try {
      const dataJson = fs.readFileSync(filePath, 'utf8')
      const dataObj = JSON.parse(dataJson)
      return storeSchema.parse(dataObj)
    } catch (error) {
      const defaultData = storeSchema.parse(storeDefault())
      const data = JSON.stringify(defaultData, null, 2)
      fs.writeFileSync(filePath, data, 'utf8')
      return defaultData
    }
  }
```

可以在解析失败后，让原有数据与默认数据结合，再次解析
```ts
  // load data from file
  const load = () => {
    let dataObj
    try {
      // 尝试从文件中读取数据
      const dataJson = fs.readFileSync(filePath, 'utf8')
      dataObj = JSON.parse(dataJson)
    } catch (error) {
      // 读取失败则使用默认数据
      dataObj = storeDefault()
    }

    let dataParse
    try {
      // 尝试用zod确保数据结构正确
      dataParse = storeSchema.parse(dataObj)
    } catch (error) {
      // 数据结构不正确，尝试将当前数据与默认数据结合
      const dataMerged = { ...storeDefault(), ...dataObj }
      try {
        // 将旧数据与默认数据结合后，进行验证
        dataParse = storeSchema.parse(dataMerged)
      } catch (error) {
        // 数据结合后仍不正确，直接使用默认数据
        dataParse = storeSchema.parse(storeDefault())
      }
    }

    // 数据解析后，始终对其做一次保存
    const dataStr = JSON.stringify(dataParse, null, 2)
    fs.writeFileSync(filePath, dataStr, 'utf8')
    // 返回解析后的数据
    return dataParse
  }
```

但这样还是不完美，