

## 主图的裁切
```ts
const mergeImage = async (uploadFile: UploadFile) => {
  // loadImageFromFile 这个函数已经有了
  // loadImageFromFile: (uploadFile: UploadFile) => Promise<HTMLImageElement>
  const imageEl = await loadImageFromFile(uploadFile)

  // 我将这张图片分为四份（左上、右上、左下、右下），以下是详细要求
  // 1 首先将图片按“cover”方式裁剪为16比9，并记录图片此时的大小（长与宽）
  // 2 将图片放大两倍（关于为什么要这样，是因为我想让图片分为四份后，每个图片和原图大小一样）
  // 3 将图片裁剪为分为四份（左上、右上、左下、右下）
  // 我个人觉得有以上要点，你要详细讲讲，你还可以补充

  // 以下是一些提示，尽量配合这些

  // 用 canvas context 进行图片处理
  // const canvas = document.createElement('canvas')
  // const context = canvas.getContext('2d') as CanvasRenderingContext2D

  // 最终保存
  // mergedImageLT.value = canvas1.toDataURL('image/png')
  // mergedImageRT.value = canvas2.toDataURL('image/png')
  // mergedImageLB.value = canvas3.toDataURL('image/png')
  // mergedImageRB.value = canvas4.toDataURL('image/png')
}
```

为了实现你提到的需求，我将分步骤详细解释如何处理这张图片，并给出完整的代码。

### 处理步骤：

1. **裁剪为 16:9 的图片**：你想要以 `cover` 的方式裁剪图片，这意味着我们需要保持 16:9 的宽高比，并根据图片的尺寸计算裁剪的区域。
2. **放大图片两倍**：裁剪后的图片将被放大两倍，这样在后续分割成四份时，每一份的大小与原始图像一样。
3. **将图片分为四份**：放大后的图片将被等分为左上、右上、左下、右下四份，每一份的尺寸将和原始裁剪图像一致。

### 步骤解析：

#### 1. 裁剪为 16:9 并记录图片大小
- 计算图片的宽高比，找出裁剪区域，使得最终的裁剪符合 16:9 的比例。

#### 2. 放大图片两倍
- 使用 `context.scale(2, 2)` 将图像放大两倍。

#### 3. 分成四份
- 将放大的图片按尺寸分割为四个等份，分别绘制到新的 `canvas` 中。

### 实现代码：

```typescript
const mergeImage = async (uploadFile: UploadFile) => {
  // 1. 加载图片
  const imageEl = await loadImageFromFile(uploadFile);

  // 2. 创建一个 canvas 和 context 用来处理图像
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d') as CanvasRenderingContext2D;

  // 3. 获取图片的原始尺寸
  const originalWidth = imageEl.width;
  const originalHeight = imageEl.height;

  // 4. 计算裁剪后的 16:9 区域
  const targetAspectRatio = 16 / 9;
  let cropWidth = originalWidth;
  let cropHeight = originalHeight;

  // 根据原始图片的宽高比决定裁剪的区域
  if (originalWidth / originalHeight > targetAspectRatio) {
    cropWidth = originalHeight * targetAspectRatio;
  } else {
    cropHeight = originalWidth / targetAspectRatio;
  }

  const cropX = (originalWidth - cropWidth) / 2; // 横向居中裁剪
  const cropY = (originalHeight - cropHeight) / 2; // 纵向居中裁剪

  // 5. 调整 canvas 大小为裁剪后的大小
  canvas.width = cropWidth;
  canvas.height = cropHeight;

  // 6. 将裁剪后的图片绘制到 canvas 中
  context.drawImage(
    imageEl,
    cropX, cropY, cropWidth, cropHeight,  // 裁剪区域
    0, 0, cropWidth, cropHeight           // 绘制到 canvas
  );

  // 7. 放大两倍
  const scaledCanvas = document.createElement('canvas');
  scaledCanvas.width = cropWidth * 2;
  scaledCanvas.height = cropHeight * 2;
  const scaledContext = scaledCanvas.getContext('2d') as CanvasRenderingContext2D;

  // 放大图像
  scaledContext.scale(2, 2);
  scaledContext.drawImage(canvas, 0, 0);

  // 8. 将放大后的图像分为四份（左上、右上、左下、右下）
  const halfWidth = scaledCanvas.width / 2;
  const halfHeight = scaledCanvas.height / 2;

  const createSplitCanvas = (sx: number, sy: number, sw: number, sh: number): string => {
    const splitCanvas = document.createElement('canvas');
    const splitContext = splitCanvas.getContext('2d') as CanvasRenderingContext2D;
    splitCanvas.width = sw;
    splitCanvas.height = sh;
    splitContext.drawImage(scaledCanvas, sx, sy, sw, sh, 0, 0, sw, sh);
    return splitCanvas.toDataURL('image/png');
  };

  // 左上 (LT)
  const mergedImageLT = createSplitCanvas(0, 0, halfWidth, halfHeight);

  // 右上 (RT)
  const mergedImageRT = createSplitCanvas(halfWidth, 0, halfWidth, halfHeight);

  // 左下 (LB)
  const mergedImageLB = createSplitCanvas(0, halfHeight, halfWidth, halfHeight);

  // 右下 (RB)
  const mergedImageRB = createSplitCanvas(halfWidth, halfHeight, halfWidth, halfHeight);

  // 9. 返回处理后的图像
  return {
    mergedImageLT,
    mergedImageRT,
    mergedImageLB,
    mergedImageRB
  };
};
```

### 代码详解：
1. **裁剪图片为 16:9**：
   - 根据图片的宽高比计算出裁剪区域，使其符合 16:9 的比例。
   - 使用 `context.drawImage()` 进行裁剪。
   
2. **放大图像**：
   - 创建一个新的 `canvas`，使用 `context.scale(2, 2)` 来将图像放大两倍，这样分割成四份后每份和原图大小一致。

3. **分割图片**：
   - 使用 `createSplitCanvas()` 函数分别将图片的左上、右上、左下、右下部分切割出来，并通过 `canvas.toDataURL()` 将它们转换为 Base64 格式。

### 结果：
这个函数会返回四个分割后的图像，分别是左上、右上、左下和右下的图片，且每个图片和原始图片的大小一致。

### 保存
要将处理后的四张图片保存到 `mergedImageLT.value`、`mergedImageRT.value` 等变量，你可以将结果赋值给这些变量。假设你使用的是 Vue 3 中的 `ref`，你可以这样做：

### 假设你已经有以下的 `ref` 变量：

```typescript
import { ref } from 'vue';

const mergedImageLT = ref('');
const mergedImageRT = ref('');
const mergedImageLB = ref('');
const mergedImageRB = ref('');
```

### 在 `mergeImage` 函数中将生成的图片赋值给它们：

```typescript
const mergeImage = async (uploadFile: UploadFile) => {
  // 1. 加载图片
  const imageEl = await loadImageFromFile(uploadFile);

  // 2. 创建一个 canvas 和 context 用来处理图像
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d') as CanvasRenderingContext2D;

  // 3. 获取图片的原始尺寸
  const originalWidth = imageEl.width;
  const originalHeight = imageEl.height;

  // 4. 计算裁剪后的 16:9 区域
  const targetAspectRatio = 16 / 9;
  let cropWidth = originalWidth;
  let cropHeight = originalHeight;

  if (originalWidth / originalHeight > targetAspectRatio) {
    cropWidth = originalHeight * targetAspectRatio;
  } else {
    cropHeight = originalWidth / targetAspectRatio;
  }

  const cropX = (originalWidth - cropWidth) / 2;
  const cropY = (originalHeight - cropHeight) / 2;

  // 5. 调整 canvas 大小为裁剪后的大小
  canvas.width = cropWidth;
  canvas.height = cropHeight;

  // 6. 将裁剪后的图片绘制到 canvas 中
  context.drawImage(
    imageEl,
    cropX, cropY, cropWidth, cropHeight,
    0, 0, cropWidth, cropHeight
  );

  // 7. 放大两倍
  const scaledCanvas = document.createElement('canvas');
  scaledCanvas.width = cropWidth * 2;
  scaledCanvas.height = cropHeight * 2;
  const scaledContext = scaledCanvas.getContext('2d') as CanvasRenderingContext2D;

  scaledContext.scale(2, 2);
  scaledContext.drawImage(canvas, 0, 0);

  // 8. 将放大后的图像分为四份
  const halfWidth = scaledCanvas.width / 2;
  const halfHeight = scaledCanvas.height / 2;

  const createSplitCanvas = (sx: number, sy: number, sw: number, sh: number): string => {
    const splitCanvas = document.createElement('canvas');
    const splitContext = splitCanvas.getContext('2d') as CanvasRenderingContext2D;
    splitCanvas.width = sw;
    splitCanvas.height = sh;
    splitContext.drawImage(scaledCanvas, sx, sy, sw, sh, 0, 0, sw, sh);
    return splitCanvas.toDataURL('image/png');
  };

  // 9. 将结果保存到 ref 变量中
  mergedImageLT.value = createSplitCanvas(0, 0, halfWidth, halfHeight);
  mergedImageRT.value = createSplitCanvas(halfWidth, 0, halfWidth, halfHeight);
  mergedImageLB.value = createSplitCanvas(0, halfHeight, halfWidth, halfHeight);
  mergedImageRB.value = createSplitCanvas(halfWidth, halfHeight, halfWidth, halfHeight);
};
```

### 说明：
1. 我假设你使用 Vue 3 中的 `ref` 变量来保存这些图片的 Base64 字符串。如果你使用 `reactive` 或其他 Vue 3 响应式 API，请根据需要调整。
2. 调用 `mergeImage(uploadFile)` 后，`mergedImageLT.value` 等变量将保存裁剪后的四张图片的 Base64 编码数据，你可以在模板中直接使用它们来展示或下载图片。

### 最终保存：
- `mergedImageLT.value`，`mergedImageRT.value`，`mergedImageLB.value` 和 `mergedImageRB.value` 将分别保存四份裁剪后的图片数据，你可以根据需要显示或进一步处理这些数据。


## 图片的拼接
```
好，现在我想进一步实现功能

const ltImageFiles = ref<UploadUserFile[]>([])
const rtImageFiles = ref<UploadUserFile[]>([])
const lbImageFiles = ref<UploadUserFile[]>([])
const rbImageFiles = ref<UploadUserFile[]>([])

以上数组每个最多有两个
含义：lt（left top）、rb（right bottom）

我想在将主图切割后，从以上数组中获取图片并进行操作
1 将所有图片按“cover”方式裁剪为16比9
2 将所有图片进行缩放，大小就为主图切割后一份的大小
3 将对应数组中的图片，和切割后的主图拼接，详情如下
    3.1 如lt（left top）代表左上，则这个数组和主图切割后的左上部分拼接，其余三个同理
    3.2 数组中的第一个图片拼接在 主图切割后（以下简称主切）的上方，第二个图片拼接在主切下方
    3.3 如果数组中只有一个图片，则主切的上方和下方都为这个图片。
    3.4 如果数组中没有图片，则不进行拼接，保留主切原本
4 完成上述拼接后，像原来一样，将四个图片保存为 toDataURL('image/png')
```

为了解决你的需求，可以按照以下步骤进行：

1. **裁剪为 16:9**：获取数组中的每张图片，按 `cover` 方式裁剪为 16:9。
2. **缩放图片**：将图片缩放为主图切割后的一份大小（即四分之一主图的大小）。
3. **拼接图片**：
   - 根据数组的长度，决定如何拼接图片与主图切割的对应部分：
     - 如果有两张图片：第一张放在主切的上方，第二张放在主切的下方。
     - 如果有一张图片：上下都拼接这张图片。
     - 如果没有图片：保留原来的主切部分。
4. **保存处理后的图片**：使用 `toDataURL('image/png')` 保存处理后的四张图片。

### 实现代码

```typescript
const mergeImage = async (uploadFile: UploadFile) => {
  const imageEl = await loadImageFromFile(uploadFile);
  
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d') as CanvasRenderingContext2D;

  // 获取主图的原始尺寸
  const originalWidth = imageEl.width;
  const originalHeight = imageEl.height;

  // 计算裁剪的 16:9 区域
  const targetAspectRatio = 16 / 9;
  let cropWidth = originalWidth;
  let cropHeight = originalHeight;
  
  if (originalWidth / originalHeight > targetAspectRatio) {
    cropWidth = originalHeight * targetAspectRatio;
  } else {
    cropHeight = originalWidth / targetAspectRatio;
  }

  const cropX = (originalWidth - cropWidth) / 2;
  const cropY = (originalHeight - cropHeight) / 2;

  // 裁剪后调整 canvas 大小
  canvas.width = cropWidth;
  canvas.height = cropHeight;

  // 裁剪主图并绘制到 canvas
  context.drawImage(
    imageEl,
    cropX, cropY, cropWidth, cropHeight, 
    0, 0, cropWidth, cropHeight
  );

  // 放大图片两倍
  const scaledCanvas = document.createElement('canvas');
  scaledCanvas.width = cropWidth * 2;
  scaledCanvas.height = cropHeight * 2;
  const scaledContext = scaledCanvas.getContext('2d') as CanvasRenderingContext2D;

  scaledContext.scale(2, 2);
  scaledContext.drawImage(canvas, 0, 0);

  const halfWidth = scaledCanvas.width / 2;
  const halfHeight = scaledCanvas.height / 2;

  // 辅助函数：裁剪并缩放数组中的图片
  const cropAndScaleImage = async (file: UploadFile, width: number, height: number): Promise<HTMLCanvasElement> => {
    const img = await loadImageFromFile(file);
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempContext = tempCanvas.getContext('2d') as CanvasRenderingContext2D;

    // 裁剪为 16:9 并缩放
    const aspectRatio = img.width / img.height;
    let sx = 0, sy = 0, sWidth = img.width, sHeight = img.height;
    if (aspectRatio > targetAspectRatio) {
      sWidth = img.height * targetAspectRatio;
      sx = (img.width - sWidth) / 2;
    } else {
      sHeight = img.width / targetAspectRatio;
      sy = (img.height - sHeight) / 2;
    }
    
    tempContext.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, width, height);
    return tempCanvas;
  };

  // 辅助函数：拼接主图切片与数组中的图片
  const mergeWithArray = async (partCanvas: HTMLCanvasElement, imagesArray: UploadFile[], width: number, height: number): Promise<HTMLCanvasElement> => {
    const mergedCanvas = document.createElement('canvas');
    mergedCanvas.width = width;
    mergedCanvas.height = height * 3; // 原主切部分+两个拼接部分的高度
    const mergedContext = mergedCanvas.getContext('2d') as CanvasRenderingContext2D;

    if (imagesArray.length > 0) {
      // 第一个图片在上方
      const topImageCanvas = await cropAndScaleImage(imagesArray[0], width, height);
      mergedContext.drawImage(topImageCanvas, 0, 0);

      // 主切部分在中间
      mergedContext.drawImage(partCanvas, 0, height);

      // 第二个图片在下方（如果有）
      const bottomImageCanvas = await cropAndScaleImage(imagesArray[1] || imagesArray[0], width, height);
      mergedContext.drawImage(bottomImageCanvas, 0, height * 2);
    } else {
      // 没有图片，保持主切部分原样
      mergedCanvas.height = height;
      mergedContext.drawImage(partCanvas, 0, 0);
    }

    return mergedCanvas;
  };

  // 创建切片
  const partLT = scaledCanvas.getContext('2d')?.getImageData(0, 0, halfWidth, halfHeight);
  const partRT = scaledCanvas.getContext('2d')?.getImageData(halfWidth, 0, halfWidth, halfHeight);
  const partLB = scaledCanvas.getContext('2d')?.getImageData(0, halfHeight, halfWidth, halfHeight);
  const partRB = scaledCanvas.getContext('2d')?.getImageData(halfWidth, halfHeight, halfWidth, halfHeight);

  // 拼接图片
  const mergedLT = await mergeWithArray(partLT, ltImageFiles.value, halfWidth, halfHeight);
  const mergedRT = await mergeWithArray(partRT, rtImageFiles.value, halfWidth, halfHeight);
  const mergedLB = await mergeWithArray(partLB, lbImageFiles.value, halfWidth, halfHeight);
  const mergedRB = await mergeWithArray(partRB, rbImageFiles.value, halfWidth, halfHeight);

  // 保存最终图片
  mergedImageLT.value = mergedLT.toDataURL('image/png');
  mergedImageRT.value = mergedRT.toDataURL('image/png');
  mergedImageLB.value = mergedLB.toDataURL('image/png');
  mergedImageRB.value = mergedRB.toDataURL('image/png');
};
```

### 关键点：
1. **裁剪**：通过 `cropAndScaleImage` 函数裁剪所有图片为 16:9，并缩放至指定大小。
2. **拼接**：通过 `mergeWithArray` 函数，拼接每个数组中的图片与主图切割部分。如果数组为空，保留原主切；如果有图片，将其拼接到主切上下。
3. **最终保存**：将每个拼接后的图片转为 Base64 并保存。

### 总结：
该实现按照你的要求裁剪、缩放并拼接图片，并保存为最终的四个图像。每个拼接部分根据数组中的图片进行不同的处理，适应不同的图片数量。


```
在执行时出现了错误 XImgCut.vue:346 Canvas2D: Multiple readback operations using getImageData are faster with the willReadFrequently attribute set to true. See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently XImgCut.vue:334 Uncaught (in promise) TypeError: Failed to execute 'drawImage' on 'CanvasRenderingContext2D': The provided value is not of type '(CSSImageValue or HTMLCanvasElement or HTMLImageElement or HTMLVideoElement or ImageBitmap or OffscreenCanvas or SVGImageElement or VideoFrame)'. at mergeWithArray (XImgCut.vue:334:21) at mergeImage (XImgCut.vue:355:26) at async Proxy.handleMainImageUpload (XImgCut.vue:34:3)
```

这些错误有两个主要原因：

1. **性能警告**：`willReadFrequently` 属性未设置。浏览器提示在频繁使用 `getImageData` 时，应将 `willReadFrequently` 属性设置为 `true`，以提高性能。
   
2. **`drawImage` 类型错误**：`getImageData` 返回的是 `ImageData` 对象，而 `drawImage` 需要的是 `HTMLCanvasElement`、`HTMLImageElement` 等类型。

### 解决方案

#### 1. **设置 `willReadFrequently` 属性**

在创建 `2d` 上下文时，使用 `willReadFrequently: true` 属性来避免性能问题。

```typescript
const context = canvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;
```

#### 2. **修复 `drawImage` 类型错误**

`getImageData` 返回的是像素数据，不适合直接传入 `drawImage`。你需要直接使用 `canvas` 或将其转换为 `ImageBitmap` 以供 `drawImage` 使用。可以调整 `mergeWithArray` 函数，确保传递正确的对象类型。

将 `getImageData` 替换为裁剪后的 `canvas`，因为你已经有 `canvas` 实例：

```typescript
const partLTCanvas = document.createElement('canvas');
const partLTContext = partLTCanvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;
partLTCanvas.width = halfWidth;
partLTCanvas.height = halfHeight;
partLTContext.drawImage(scaledCanvas, 0, 0, halfWidth, halfHeight);
```

### 更新后的代码

```typescript
const mergeImage = async (uploadFile: UploadFile) => {
  const imageEl = await loadImageFromFile(uploadFile);

  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;

  // 获取主图的原始尺寸
  const originalWidth = imageEl.width;
  const originalHeight = imageEl.height;

  // 计算裁剪的 16:9 区域
  const targetAspectRatio = 16 / 9;
  let cropWidth = originalWidth;
  let cropHeight = originalHeight;

  if (originalWidth / originalHeight > targetAspectRatio) {
    cropWidth = originalHeight * targetAspectRatio;
  } else {
    cropHeight = originalWidth / targetAspectRatio;
  }

  const cropX = (originalWidth - cropWidth) / 2;
  const cropY = (originalHeight - cropHeight) / 2;

  canvas.width = cropWidth;
  canvas.height = cropHeight;

  // 裁剪主图并绘制到 canvas
  context.drawImage(
    imageEl,
    cropX, cropY, cropWidth, cropHeight, 
    0, 0, cropWidth, cropHeight
  );

  // 放大图片两倍
  const scaledCanvas = document.createElement('canvas');
  scaledCanvas.width = cropWidth * 2;
  scaledCanvas.height = cropHeight * 2;
  const scaledContext = scaledCanvas.getContext('2d') as CanvasRenderingContext2D;

  scaledContext.scale(2, 2);
  scaledContext.drawImage(canvas, 0, 0);

  const halfWidth = scaledCanvas.width / 2;
  const halfHeight = scaledCanvas.height / 2;

  // 创建切片 canvas
  const partLTCanvas = document.createElement('canvas');
  const partRTCanvas = document.createElement('canvas');
  const partLBCanvas = document.createElement('canvas');
  const partRBCanvas = document.createElement('canvas');

  partLTCanvas.width = partRTCanvas.width = partLBCanvas.width = partRBCanvas.width = halfWidth;
  partLTCanvas.height = partRTCanvas.height = partLBCanvas.height = partRBCanvas.height = halfHeight;

  const partLTContext = partLTCanvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;
  const partRTContext = partRTCanvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;
  const partLBContext = partLBCanvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;
  const partRBContext = partRBCanvas.getContext('2d', { willReadFrequently: true }) as CanvasRenderingContext2D;

  partLTContext.drawImage(scaledCanvas, 0, 0, halfWidth, halfHeight, 0, 0, halfWidth, halfHeight);
  partRTContext.drawImage(scaledCanvas, halfWidth, 0, halfWidth, halfHeight, 0, 0, halfWidth, halfHeight);
  partLBContext.drawImage(scaledCanvas, 0, halfHeight, halfWidth, halfHeight, 0, 0, halfWidth, halfHeight);
  partRBContext.drawImage(scaledCanvas, halfWidth, halfHeight, halfWidth, halfHeight, 0, 0, halfWidth, halfHeight);

  // 辅助函数：裁剪并缩放数组中的图片
  const cropAndScaleImage = async (file: UploadFile, width: number, height: number): Promise<HTMLCanvasElement> => {
    const img = await loadImageFromFile(file);
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = width;
    tempCanvas.height = height;
    const tempContext = tempCanvas.getContext('2d') as CanvasRenderingContext2D;

    // 裁剪为 16:9 并缩放
    const aspectRatio = img.width / img.height;
    let sx = 0, sy = 0, sWidth = img.width, sHeight = img.height;
    if (aspectRatio > targetAspectRatio) {
      sWidth = img.height * targetAspectRatio;
      sx = (img.width - sWidth) / 2;
    } else {
      sHeight = img.width / targetAspectRatio;
      sy = (img.height - sHeight) / 2;
    }
    
    tempContext.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, width, height);
    return tempCanvas;
  };

  // 辅助函数：拼接主图切片与数组中的图片
  const mergeWithArray = async (partCanvas: HTMLCanvasElement, imagesArray: UploadFile[], width: number, height: number): Promise<HTMLCanvasElement> => {
    const mergedCanvas = document.createElement('canvas');
    mergedCanvas.width = width;
    mergedCanvas.height = height * 3; // 原主切部分+两个拼接部分的高度
    const mergedContext = mergedCanvas.getContext('2d') as CanvasRenderingContext2D;

    if (imagesArray.length > 0) {
      // 第一个图片在上方
      const topImageCanvas = await cropAndScaleImage(imagesArray[0], width, height);
      mergedContext.drawImage(topImageCanvas, 0, 0);

      // 主切部分在中间
      mergedContext.drawImage(partCanvas, 0, height);

      // 第二个图片在下方（如果有）
      const bottomImageCanvas = await cropAndScaleImage(imagesArray[1] || imagesArray[0], width, height);
      mergedContext.drawImage(bottomImageCanvas, 0, height * 2);
    } else {
      // 没有图片，保持主切部分原样
      mergedCanvas.height = height;
      mergedContext.drawImage(partCanvas, 0, 0);
    }

    return mergedCanvas;
  };

  // 拼接图片
  const mergedLT = await mergeWithArray(partLTCanvas, ltImageFiles.value, halfWidth, halfHeight);
  const mergedRT = await mergeWithArray(partRTCanvas, rtImageFiles.value, halfWidth, halfHeight);
  const mergedLB = await mergeWithArray(partLBCanvas, lbImageFiles.value, halfWidth, halfHeight);
  const mergedRB = await mergeWithArray(partRBCanvas, rbImageFiles.value, halfWidth, halfHeight);

  // 保存最终图片
  mergedImageLT.value = mergedLT.toDataURL('image/png');
  mergedImageRT.value = mergedRT.toDataURL('image/png');
  mergedImageLB.value = mergedLB.toDataURL('image/png');
  mergedImageRB.value = mergedRB.toDataURL('image/png');
};
```

### 关键修复：
- **`willReadFrequently` 属性**：在频繁使用 `getImageData` 时设置以优化性能。
- **`drawImage` 类型错误**：使用 `canvas` 而不是 `getImageData` 结果直接传入 `drawImage`，确保类型匹配。